
#include <stdio.h>
#include <x86asm.h>
#include <x86dis.h>

int CallBackTest(void *context, const char *s, uint64 &v)
{
	printf("CallBack: %s,%lu\n",s,v);
// 	if (strcmp(s,"ebx") == 0)
// 	{
// 		v = 0x10000;
// 		return 1;
// 	}
	return 0;
}

int main(int argc, char* argv[])
{
	//反汇编测试
	printf("反汇编测试\n");
	x86dis	decoder(X86_OPSIZE32,X86_ADDRSIZE32);

	unsigned char data[] =
	{
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x55, 0x8B, 0xEC, 0x56, 0x8B, 0xF1, 
		0xE8, 0x0C, 0x96, 0x04, 0x00, 0xF6, 0x45, 0x08, 0x01, 0x74, 0x09, 0x56, 0xE8, 0x9C, 0x45, 0x00, 
		0x00, 0x83, 0xC4, 0x04, 0x8B, 0xC6, 0x5E, 0x5D, 0xC2, 0x04, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 
		0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xC5, 0xF8, 0x57, 0xC0, 0xC7, 0x05, 
		0xB8, 0xEC, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x05, 0xCC, 0xEC, 0xCA, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0xC7, 0x05, 0xD0, 0xEC, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x05, 0xD4, 0xEC, 
		0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x05, 0xDC, 0xEC, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0xC7, 0x05, 0xE4, 0xEC, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x05, 0xE8, 0xEC, 0xCA, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0xC7, 0x05, 0xEC, 0xEC, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x05, 
		0xF0, 0xEC, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x05, 0xF4, 0xEC, 0xCA, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0xC7, 0x05, 0xF8, 0xEC, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0xFA, 0x7F, 0x05, 
		0x00, 0xED, 0xCA, 0x00, 0xC7, 0x05, 0x14, 0xED, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x05, 
		0x18, 0xED, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x05, 0x1C, 0xED, 0xCA, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0xC7, 0x05, 0x24, 0xED, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x05, 0x28, 0xED, 
		0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x05, 0x30, 0xED, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0xC5, 0xFA, 0x7F, 0x05, 0x38, 0xED, 0xCA, 0x00, 0xC7, 0x05, 0x54, 0xED, 0xCA, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0xC7, 0x05, 0x74, 0xED, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x05, 0x78, 0xED, 
		0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC2, 0x04, 0x00, 0xCC
	};

	CPU_ADDR	addr;
	addr.addr32.seg = 0;
	addr.addr32.offset = 0x401002;
	for (int i=0;i<sizeof(data);)
	{
		x86dis_insn* insn = (x86dis_insn*)decoder.decode(data+i,sizeof(data)-i,addr);
		const char* pcsIns = decoder.str(insn,DIS_STYLE_HEX_ASMSTYLE | DIS_STYLE_HEX_UPPERCASE | DIS_STYLE_HEX_NOZEROPAD | DIS_STYLE_SIGNED);
		printf("%08X\t%s\n",addr.addr32.offset, pcsIns);
		addr.addr32.offset += insn->size;
		i += insn->size;
	}

	//汇编测试
	x86asm	encoder(X86_OPSIZE32,X86_ADDRSIZE32);

	//这个回调似乎是用来返回指定寄存器/Symbol的值
	//比如汇编“add eax,ebx”这条指令，会通过回调函数来确定eax和ebx的值，
	//值通过最后一个参数返回
	//给指定symbol设置值后会以该值替换原来的值
	//比如“add eax,ebx”在回调中收到ebx时返回0x10000就相当于汇编“add eax,10000h”
	//不想返回就设置NULL或者在回调中返回0
	encoder.set_imm_eval_proc(CallBackTest,NULL);

	const char* psAsmTxt = "vmovdqu     [13299000], xmm0";

	printf("编译汇编指令：%s\n",psAsmTxt);
	asm_insn* pInsn = encoder.alloc_insn();
	if (!encoder.translate_str(pInsn,psAsmTxt))
	{
		printf("translate_str failed");
		return 0;
	}

	asm_code* pAsmCode = encoder.encode(pInsn,0,addr);

	int i = 0;
	while (pAsmCode)
	{
		char s[1024], *tmp = s;
		for (int i=0; i < pAsmCode->size; i++)
		{
			tmp += sprintf(tmp, "%02x ", pAsmCode->data[i]);
		}
		pAsmCode = pAsmCode->next;
		++i;
		printf("机器码%d:%s\n",i,s);
	}

	return 0;
}

